# Basic Version
Token token

word    := R'[a-zA-Z_][a-z0-9A-Z_]*';
escape  := '\\' ;
newline := '\n' ;
number  := R'\d+';

bit     ::= R'0[XxOoBb][\da-fA-F]+'; # ast



symbol ::=  '`' word '`' | word;

argument ::=  (declaration| expression) (',' (declaration|expression) )*;

declaration ::= symbol ( '(' [argument] ')' )* [':' typedef];

definition Throw ['\n'] 
    ::= declaration '=' newline* expression;

body Throw ['\n']  
    ::= '{' (newline* expression)* '}';
# a = { ... } 

branch 
    ::= 'when' expression 'then' expression;


endOfBranch  # guard-like(god-like?emmmm....
    ::= 'otherwise' 'then' expression;

guard Throw ['\n'] 
    ::= (branch newline*)+ [endOfBranch]; 

# a = when false then 2
#     otherwise then 

expression ::= body | guard | definition | dualOperation;

dualOperation ::= unaryOperation (dualOperator unaryOperation)*;

dualOperator ::= '+' | '-' | '*' | '/' | '%'  |
                  '++'| '--'| '**'| '//'|
                  '^' | '&' | '|' | '>>'| '<<' |
                  '^^'| '&&'| '||'|
                  '~' |'and'| 'or'| 'in'|
                  '$' | '@' | '|>'| 
                  '>' | '<' | '>='| '<='|
                  '=='| 
                  '<-';

unaryHeadOperator ::= 'not' | '!';
unaryLastOperator ::= '??'  | '?';
unaryOperation ::= unaryHeadOperator* atomExpr [unaryLastOperator];

lambdef ::= declaration '=>' expression ;

atomExpr ::= lambdef | atom trailer* ;

trailer ::= '[' expression (',' expression)* ']' | '(' [expression (',' expression)*] ')' ;

decimal ::=  number ['.' number] ['E' ['-'] number] ;

const  ::= 'null' | 'false' | 'true';

anyChar := R'[^"]';

string ::= '"' ('\\' '"'| anyChar)* '"';

atom ::= decimal | # decimal 
         const   |
         symbol  |
         string  |
         symbol  |
         '(' expression ')';
    
typedef ::= '(' typedef ')' | typedef '->' typedef | symbol;





         
         














# a b = 
#   when b < 5 = 10
#   otherwise = 20


  


















