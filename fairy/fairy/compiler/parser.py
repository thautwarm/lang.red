"""
This module is generated by EBNFParser.
"""
from Ruikowa.ObjectRegex.Node import Ref, AstParser, SeqParser, LiteralParser, CharParser, MetaInfo, DependentAstParser
namespace = globals()
recurSearcher = set()
word = LiteralParser('[a-zA-Z_][a-z0-9A-Z_]*', name='word', isRegex=True)
escape = LiteralParser('\\', name='escape')
newline = LiteralParser('\n', name='newline')
number = LiteralParser('\d+', name='number', isRegex=True)
bit = AstParser([LiteralParser('0[XxOoBb][\da-fA-F]+', name='\'0[XxOoBb][\da-fA-F]+\'', isRegex=True)], name='bit')
symbol = AstParser([SeqParser([LiteralParser('~', name='\'~\'')], atmost=1), Ref('word')], name='symbol')
argument = AstParser([Ref('expression')], name='argument')
arguments = AstParser([Ref('argument'), SeqParser([LiteralParser(',', name='\',\''), Ref('argument')])],
                      name='arguments')
declaration = AstParser([Ref('symbol'), SeqParser(
    [LiteralParser('(', name='\'(\''), SeqParser([Ref('argument')], atmost=1), LiteralParser(')', name='\')\'')]),
                         SeqParser([LiteralParser(':', name='\':\''), Ref('typedef')], atmost=1)], name='declaration')
definition = AstParser(
    [Ref('declaration'), LiteralParser('=', name='\'=\''), SeqParser([Ref('newline')]), Ref('expression')],
    name='definition', toIgnore=[{}, {'\n', '='}])
body = AstParser([LiteralParser('{', name='\'{\''), SeqParser([SeqParser([Ref('newline')]), Ref('expression')]),
                  SeqParser([Ref('newline')]), LiteralParser('}', name='\'}\'')], name='body', toIgnore=[{}, {'\n'}])
branch = AstParser([LiteralParser('when', name='\'when\''), Ref('expression'), LiteralParser('then', name='\'then\''),
                    Ref('expression')], name='branch')
endOfBranch = AstParser(
    [LiteralParser('otherwise', name='\'otherwise\''), LiteralParser('then', name='\'then\''), Ref('expression')],
    name='endOfBranch')
guard = AstParser(
    [SeqParser([Ref('branch'), SeqParser([Ref('newline')])], atleast=1), SeqParser([Ref('endOfBranch')], atmost=1)],
    name='guard', toIgnore=[{}, {'\n'}])
whereSyntax = AstParser(
    [LiteralParser('where', name='\'where\''), DependentAstParser([Ref('body')], [Ref('definition')])],
    name='whereSyntax')
expression = AstParser([Ref('guard')],
                       [Ref('definition'), SeqParser([SeqParser([Ref('newline')]), Ref('whereSyntax')], atmost=1)],
                       [Ref('dualOperation')], [Ref('macro')], name='expression')
macro = AstParser([LiteralParser('`', name='\'`\''), Ref('expression')], name='macro')
dualOperation = AstParser([Ref('unaryOperation'), SeqParser([Ref('dualOperator'), Ref('unaryOperation')])],
                          name='dualOperation')
dualOperator = AstParser([LiteralParser('+', name='\'+\'')], [LiteralParser('-', name='\'-\'')],
                         [LiteralParser('*', name='\'*\'')], [LiteralParser('/', name='\'/\'')],
                         [LiteralParser('%', name='\'%\'')], [LiteralParser('++', name='\'++\'')],
                         [LiteralParser('--', name='\'--\'')], [LiteralParser('**', name='\'**\'')],
                         [LiteralParser('//', name='\'//\'')], [LiteralParser('^', name='\'^\'')],
                         [LiteralParser('&', name='\'&\'')], [LiteralParser('|', name='\'|\'')],
                         [LiteralParser('>>', name='\'>>\'')], [LiteralParser('<<', name='\'<<\'')],
                         [LiteralParser('^^', name='\'^^\'')], [LiteralParser('&&', name='\'&&\'')],
                         [LiteralParser('||', name='\'||\'')], [LiteralParser('and', name='\'and\'')],
                         [LiteralParser('or', name='\'or\'')], [LiteralParser('in', name='\'in\'')],
                         [LiteralParser('$', name='\'$\'')], [LiteralParser('@', name='\'@\'')],
                         [LiteralParser('|>', name='\'|>\'')], [LiteralParser('>', name='\'>\'')],
                         [LiteralParser('<', name='\'<\'')], [LiteralParser('>=', name='\'>=\'')],
                         [LiteralParser('<=', name='\'<=\'')], [LiteralParser('==', name='\'==\'')],
                         [LiteralParser('<-', name='\'<-\'')], name='dualOperator')
unaryHeadOperator = AstParser([LiteralParser('not', name='\'not\'')], [LiteralParser('!', name='\'!\'')],
                              [LiteralParser('+', name='\'+\'')], [LiteralParser('-', name='\'-\'')],
                              name='unaryHeadOperator')
unaryLastOperator = AstParser([LiteralParser('??', name='\'??\'')], [LiteralParser('?', name='\'?\'')],
                              name='unaryLastOperator')
unaryOperation = AstParser(
    [SeqParser([Ref('unaryHeadOperator')]), Ref('atomExpr'), SeqParser([Ref('unaryLastOperator')], atmost=1)],
    name='unaryOperation')
lambdef = AstParser(
    [LiteralParser('(', name='\'(\''), SeqParser([Ref('arguments')], atmost=1), LiteralParser(')', name='\')\''),
     LiteralParser('=>', name='\'=>\''), SeqParser([Ref('newline')]), Ref('expression')], name='lambdef')
atomExpr = AstParser([Ref('lambdef')], [Ref('typing'), SeqParser([Ref('trailer')])], name='atomExpr')
trailer = AstParser([LiteralParser('[', name='\'[\''), Ref('expression'),
                     SeqParser([LiteralParser(',', name='\',\''), Ref('expression')]),
                     LiteralParser(']', name='\']\'')], [LiteralParser('(', name='\'(\''), SeqParser(
    [Ref('expression'), SeqParser([LiteralParser(',', name='\',\''), Ref('expression')])], atmost=1),
                                                         LiteralParser(')', name='\')\'')], name='trailer')
decimal = AstParser([Ref('number'), SeqParser([LiteralParser('.', name='\'.\''), Ref('number')], atmost=1), SeqParser(
    [LiteralParser('E', name='\'E\''), SeqParser([LiteralParser('-', name='\'-\'')], atmost=1), Ref('number')],
    atmost=1)], name='decimal')
const = AstParser([LiteralParser('None', name='\'None\'')], [LiteralParser('False', name='\'False\'')],
                  [LiteralParser('True', name='\'True\'')], name='const')
anyChar = LiteralParser('[^"]+', name='anyChar', isRegex=True)
string = AstParser([LiteralParser('"', name='\'\"\''), SeqParser(
    [DependentAstParser([LiteralParser('\\', name='\'\\\''), LiteralParser('"', name='\'\"\'')], [Ref('anyChar')])]),
                    LiteralParser('"', name='\'\"\'')], name='string')
typing = AstParser([Ref('atom'), SeqParser([LiteralParser(':', name='\':\''), Ref('typedef')], atmost=1)],
                   name='typing')
atom = AstParser([Ref('decimal')], [Ref('const')], [Ref('symbol')], [Ref('string')], [Ref('symbol')], [Ref('body')],
                 [LiteralParser('(', name='\'(\''), Ref('expression'), LiteralParser(')', name='\')\'')],
                 [Ref('linkedList')], name='atom')
linkedList = AstParser([LiteralParser('[', name='\'[\''), Ref('arguments'),
                        SeqParser([LiteralParser('::', name='\'::\''), Ref('symbol')], atmost=1),
                        LiteralParser(']', name='\']\'')], [LiteralParser('[', name='\'[\''), SeqParser(
    [Ref('expression'), LiteralParser('where', name='\'where\'')], atmost=1), Ref('expression'),
                                                            LiteralParser('from', name='\'from\''), Ref('expression'),
                                                            SeqParser(
                                                                [LiteralParser(',', name='\',\''), Ref('expression')]),
                                                            LiteralParser(']', name='\']\'')], name='linkedList')
typedef = AstParser([LiteralParser('(', name='\'(\''), Ref('typedef'), LiteralParser(')', name='\')\'')],
                    [Ref('typedef'), LiteralParser('->', name='\'->\''), Ref('typedef')], [Ref('symbol')],
                    name='typedef')
bit.compile(namespace, recurSearcher)
symbol.compile(namespace, recurSearcher)
argument.compile(namespace, recurSearcher)
arguments.compile(namespace, recurSearcher)
declaration.compile(namespace, recurSearcher)
definition.compile(namespace, recurSearcher)
body.compile(namespace, recurSearcher)
branch.compile(namespace, recurSearcher)
endOfBranch.compile(namespace, recurSearcher)
guard.compile(namespace, recurSearcher)
whereSyntax.compile(namespace, recurSearcher)
expression.compile(namespace, recurSearcher)
macro.compile(namespace, recurSearcher)
dualOperation.compile(namespace, recurSearcher)
dualOperator.compile(namespace, recurSearcher)
unaryHeadOperator.compile(namespace, recurSearcher)
unaryLastOperator.compile(namespace, recurSearcher)
unaryOperation.compile(namespace, recurSearcher)
lambdef.compile(namespace, recurSearcher)
atomExpr.compile(namespace, recurSearcher)
trailer.compile(namespace, recurSearcher)
decimal.compile(namespace, recurSearcher)
const.compile(namespace, recurSearcher)
string.compile(namespace, recurSearcher)
typing.compile(namespace, recurSearcher)
atom.compile(namespace, recurSearcher)
linkedList.compile(namespace, recurSearcher)
typedef.compile(namespace, recurSearcher)